generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider          = "postgresql"
  url               = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  id                               String         @id @default(cuid())
  name                             String?
  email                            String?        @unique
  password                         String?
  emailVerified                    DateTime?
  image                            String?
  role                             UserRole?
  accounts                         Account[]
  AuditLog_AuditLog_targetIdToUser AuditLog[]     @relation("AuditLog_targetIdToUser")
  AuditLog_AuditLog_userIdToUser   AuditLog[]     @relation("AuditLog_userIdToUser")
  brands                           Brand[]
  influencers                      Influencer?
  Notification                     Notification[]
  sessions                         Session[]
}

model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  token   String   @unique
  expires DateTime
  email   String   @unique
  id      String   @id @default(uuid())
}

model PasswordResetToken {
  id      String   @id @default(cuid())
  email   String   @unique
  token   String   @unique
  expires DateTime
}

model Brand {
  id                 String               @id @default(cuid())
  name               String
  userId             String
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  user               User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  campaigns          Campaign[]
  CampaignInvitation CampaignInvitation[]
}

model Campaign {
  id                 String               @id @default(cuid())
  name               String
  brandId            String
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  directData         Json?
  selfServiceData    Json?
  type               CampaignType
  endDate            DateTime
  startDate          DateTime
  status             CampaignStatus       @default(PENDING)
  brands             Brand                @relation(fields: [brandId], references: [id])
  CampaignInvitation CampaignInvitation[]
}

model Influencer {
  id                 String               @id @default(cuid())
  userId             String               @unique
  createdAt          DateTime             @default(now())
  updatedAt          DateTime             @updatedAt
  CampaignInvitation CampaignInvitation[]
  user               User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  categories         InfluencerCategory[]
  platforms          InfluencerPlatform[]
}

model Category {
  id          String               @id @default(cuid())
  name        String               @unique
  description String?
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  influencers InfluencerCategory[]
}

model InfluencerCategory {
  influencerId String
  categoryId   String
  category     Category   @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  influencer   Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)

  @@id([influencerId, categoryId])
}

model Platform {
  id          String               @id @default(cuid())
  name        String               @unique
  createdAt   DateTime             @default(now())
  updatedAt   DateTime             @updatedAt
  influencers InfluencerPlatform[]
  services    Service[]
}

model InfluencerPlatform {
  id                  String     @id @default(cuid())
  influencerId        String
  platformId          String
  accessToken         String?
  followers           Int        @default(0)
  lastSynced          DateTime?
  platformData        Json?
  posts               Int        @default(0)
  refreshToken        String?
  tokenExpiresAt      DateTime?
  username            String
  openId              String?    @unique
  igAccountType       String?
  igBusinessAccountId String?
  igEngagementRate    Float?
  igMediaCount        Int?
  igUserId            String?
  commentsCount       Int?       @default(0)
  engagementRate      Float?     @default(0)
  likesCount          Int?       @default(0)
  savesCount          Int?       @default(0)
  sharesCount         Int?       @default(0)
  views               Int        @default(0)
  influencer          Influencer @relation(fields: [influencerId], references: [id], onDelete: Cascade)
  platform            Platform   @relation(fields: [platformId], references: [id], onDelete: Cascade)
  rateCards           RateCard[]

  @@unique([influencerId, platformId])
}

model Service {
  id          String     @id @default(cuid())
  name        String
  description String?
  type        String
  isActive    Boolean    @default(true)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  platformId  String
  platform    Platform   @relation(fields: [platformId], references: [id])
  rateCards   RateCard[] // Added opposite relation field

  @@unique([platformId, name])
}

model RateCard {
  id                  String              @id @default(cuid())
  influencerPlatformId String
  serviceId           String
  price               Int
  description         String?
  autoGenerated       Boolean  @default(false)
  createdAt           DateTime            @default(now())
  updatedAt           DateTime            @updatedAt

  influencerPlatform  InfluencerPlatform @relation(fields: [influencerPlatformId], references: [id], onDelete: Cascade)
  service             Service            @relation(fields: [serviceId], references: [id], onDelete: Cascade)

  @@unique([influencerPlatformId, serviceId])
}


model OAuthState {
  id           String   @id @default(cuid())
  state        String   @unique
  codeVerifier String
  userId       String
  createdAt    DateTime @default(now())
  provider     String
  redirectUri  String?

  @@index([provider, userId])
}

model AuditLog {
  id                           String   @id
  action                       String
  message                      String
  userId                       String
  targetId                     String
  createdAt                    DateTime @default(now())
  User_AuditLog_targetIdToUser User     @relation("AuditLog_targetIdToUser", fields: [targetId], references: [id])
  User_AuditLog_userIdToUser   User     @relation("AuditLog_userIdToUser", fields: [userId], references: [id])
}

model CampaignInvitation {
  id              String         @id
  campaignId      String
  influencerId    String
  status          CampaignStatus @default(PENDING)
  message         String?
  responseMessage String?
  invitedAt       DateTime       @default(now())
  respondedAt     DateTime?
  brandId         String
  createdAt       DateTime       @default(now())
  updatedAt       DateTime
  Brand           Brand          @relation(fields: [brandId], references: [id], onDelete: Cascade)
  Campaign        Campaign       @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  Influencer      Influencer     @relation(fields: [influencerId], references: [id], onDelete: Cascade)

  @@unique([campaignId, influencerId])
}

model Notification {
  id        String           @id
  userId    String
  role      UserRole?
  title     String
  message   String
  data      Json?
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
  type      NotificationType
  User      User             @relation(fields: [userId], references: [id])

  @@index([type, createdAt], map: "idx_type_created")
  @@index([userId, isRead], map: "idx_user_unread")
}

enum UserRole {
  ADMIN
  BRAND
  INFLUENCER
}

enum CampaignType {
  DIRECT
  SELF_SERVICE
}

enum CampaignStatus {
  PENDING
  ACTIVE
  COMPLETED
  CANCELLED
  REJECTED
}

enum NotificationType {
  ROLE_UPDATE
  INVITATION
  CAMPAIGN_APPROVAL
  CAMPAIGN_REJECTION
  SYSTEM
}
